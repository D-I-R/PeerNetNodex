# PeerNetNode
# (Курсовой проект на тему:  "Исследование технологии BlockChain")

## Введение
Технология block-chain стремительно развивается не только в сфере криптовалют, но и во многих других областях, где стремятся сократить рас-ходы, повысить эффективность и отказаться от устаревших информационных инфраструктур. В проекте рассматривается наиболее популярный пример ис-пользования block-chain, а именно, в области проведения электронных денеж-ных переводов.
Цель работы
Целью данной работы является разработка алгоритмов и программы, предназначенной для моделирования технологии block-chain на примере про-стой системы «электронного кошелька».
### Задачи
**В работе были выделены подзадачи:**
1. Выполнить анализ требований;
2. Разработать архитектуру приложения;
3. Реализовать приложение для моделирования block-chain;
4. Подготовить документацию.

## Ход работы
### Теоретическая часть
Принципы организации block-chain
Идея block-chain DLT (Distributed Ledger Technology = технология рас-пределённых регистров, или реестров) представляет собой широкую концеп-цию и набор технологий, в которых имеется база данных или общая запись транзакций, с множеством копий, распределённых среди участников сети. Це-почка блоков или блокчейн хранит информацию в блоках транзакций. В настоящее время появляются новые технологии DLT, которые используют различные структуры хранения данных, такие как Hyperledger или HashGraph.
С точки зрения кибербезопасности протокол blockchain / DLT имеет определённые особенности, которые представляют преимущество перед дру-гими технологиями. 
Сущность распределённой, или децентрализованной, архитектуры со-стоит в том, что участники сети, также известные как узлы, хранят собствен-ную копию записи всех сохранённых в системе данных, которая синхронизи-руется с копиями информации остальных участников. Такое дублирование реестра даёт возможность узлу синхронизировать свою копию реестра, в слу-чае её неактуальности, порчи или утраты, через другие узлы.
В целом, этот тип архитектуры хранения информации менее привлека-телен для злоумышленников, чем централизованные базы данных, которые становятся очень уязвимыми информационными нишами.

### Практическая часть
Одноранговая сеть узлов – основа данной модели block-chain
Технология block-chain предполагает наличие сетевой среды, в которой осуществляется обмен блоками данных между узлами сети. При построении модели системы block-chain необходимо иметь доступ хотя бы к небольшому фрагменту сети. Использование реальной сети, локальной или интернет, воз-можно, но затруднительно технически и организационно. Поэтому в качестве сетевой среды в проекте используется модель одноранговой сети.
Желательно, чтобы одноранговая сеть строилась путём многократного запуска одного и того же приложения; при этом каждый экземпляр приложе-ния имитировал бы отдельный сетевой узел. Коммуникация между узлами осуществляется при помощи стандартного механизма операционной системы Windows – именованных каналов (named pipes). В ОС Windows механизм именованных каналов относится к базовым средствам и реализован на уровне ядра. На нём основана реализация ряда протоколов взаимодействия в ОС.
Основными аргументами в пользу такого выбора является относитель-ная простота реализации и ограниченность требуемых средств, а также нали-чие хорошо документированного программного интерфейса.
Соединение двух узлов обычным именованным каналом предполагает разделение функций узлов на сервер и клиент, то есть узлы предполагаются неравноправными. Сервер создаёт именованный канал посредством CreateNamedPipe() и после вызова ConnectNamedPipe() ждёт подключение к каналу со стороны клиента. Клиент вызывает CreateFile() для подключения к каналу со своей стороны. Кстати, именованный канал (что видно и по назва-ниям функций) в операционной системе рассматривается как разновидность потока ввода-вывода. Далее с помощью вызова функций ReadFile() и WriteFile() между сервером и клиентом происходит обмен сообщениями (блоками данных), причём клиент посылает серверу запросы и получает от сервера ответы. В обмене ведущую роль играет клиент, а сервер только от-вечает на запросы клиента. Прекращение обмена может происходить как со стороны клиента вызовом CloseHandle(), так и со стороны сервера вызовом DisconnectNamedPipe(). Описанный протокол взаимодействия, соответствую-щий режиму синхронных операций ввода/вывода, проиллюстрирован на Рис. 1.

 
Рис. 1. Протокол взаимодействия сервера и клиента через 
именованный канал в синхронном режиме.
Разделение функций узлов на сервер и клиенты не подходит для сети, которая была бы основой модели block-chain. Для этой цели нужна одноран-говая сеть, в которой каждый узел мог бы выполнять и функцию сервера, и функцию клиента. Таким образом, в каждом узле должны быть совмещены обе функции.
В предлагаемой модели одноранговой сети каждый узел должен быть соединён с каждым из остальных узлов парой именованных каналов по прин-ципу «точка-точка». Для избежания путаницы каждый сервер создаёт и об-служивает несколько экземпляров канала (по числу клиентов) со своим име-нем. Такой подход приводит к конфигурации сети, приведённой на Рис. 2, для случая трёх узлов. Эту конфигурацию нетрудно обобщить на случай произвольного количества узлов N. Общее количество экземпляров имено-ванных каналов равно N·(N - 1), оно имеет порядок роста N2, что можно счи-тать недостатком предложенного метода построения сети. Но для ограничен-ной модели количество узлов невелико, поэтому данный недостаток можно считать несущественным.

 
Рис. 2. Конфигурация модели одноранговой сети на основе 
именованных каналов (для случая трёх узлов).
Алгоритмы функционирования узла одноранговой сети
Модель рассчитана на формирование одноранговой сети с количеством узлов до семи. Узлы сети образуются экземплярами приложения, которые мо-гут запускаться как на одном и том же, так и на разных компьтерах, включён-ных в одну локальную сеть. В данной версии программной реализации пред-полагается работа на одном компьютере, с целью упрощения поиска подхо-дящих серверов именованных каналов.
Программная реализацияузла одноранговой сети представлена двумя основными классами: CNamedPipe и CPeerNetNode. Реализация как сервера, так и клиента представляет собой многопоточную программу. Отдельный программный поток управляет своим экземпляром именованного канала со стороны сервера, также отдельный программный поток обеспечивает обмен сообщениями по именованному каналу со стороны клиента. Количество про-граммных потоков одного узла определяется по формуле 2(N - 1) + 2 = 2N, где N – общее количество узлов, N-1 – количество узлов, с которыми соеди-нён один узел, +2 – количество потоков, не связанных с именованными кана-лами (основной программный поток и серверный поток «прослушивания» се-ти). Таким образом, общее количество программных потоков, обеспечиваю-щих всю сеть, – 2N2.
В классе CNamedPipe реализованы структуры данных, необходимые для работы с именованными каналами: буферы запроса клиента и ответа сервера, объекты синхронизации выполнения программных потоков, объекты иденти-фикации узла, канала, состояния канала, коды ошибок. Методы класса реали-зуют базовые операции обмена сообщениями по именованному каналу и об-работку ошибок.
В классе CPeerNetNode представлены структуры данных узла одноран-говой сети: массив экземпляров именованного канала серверной части узла, массив именованных каналов клиентской части узла, количество активных уз-лов сети, номер «своего» узла. Методы класса обеспечивают: запуск и останов узла, передачу запроса серверу заданного узла и получение ответа.
Для начала функционирования очередного узла одноранговой сети пользователь должен пройти авторизацию, при которой определяется услов-ный номер пользователя, и вызвать процедуру CPeerNetNode::StartupNode(). Алгоритм запуска узла сети приведён на Рис. 3. Сначала запускается клиент-ская часть узла. В цикле делается попытка запуска клиента поочерёдно на всех каналах. Если попытка на канале k оказывается успешной, значит, узел сети с номером k активен и для него выполняется процедура CPeerNetNode:: 
 
Рис. 3. Алгоритм запуска узла одноранговой сети на основе именованных ка-налов.
StartNPClient(k), которая формирует экземпляр именованного канала со сто-роны клиента и помещает его в k-й элемент массива клиентских каналов. Если на канале k не удаётся запустить клиент, значит, нет узла с номером k, и этот номер вносится в список свободных номеров узлов. По окончании цикла опроса существующих узлов сети будут запущены клиенты всех активных уз-лов, номера неактивных узлов будут помещены в список свободных номеров.
Далее процедурой CPeerNetNode::StartNPServer() запускается серверная часть для первого свободного номера узла; запускаемый узел получает номер. Устанавливается соответствие условного номера пользователя и номера узла, что необходимо для правильной адресации сообщений.
После этого всем активным в данный момент узлам сети, для которых в первой части алгоритма были сформированы клиентские каналы, рассылается служебная команда SCL (StartCLient) – «запустить клиент» для нового узла сети. При получении этой команды в каждом из ранее активных узлов будет запущен клиент и создан канал для связи с вновь запущенным сервером.
Синхронизация программных потоков для случая минимальной конфи-гурации сети из двух узлов иллюстрируется Рис. 4. В этом случае на каждом узле работают по четыре потока: основной программный поток, серверный поток «прослушивания» и пара потоков обслуживания именованных каналов, связывающих узлы.
Алгоритм запуска клиента на k-м канале CPeerNetNode::StartNPClient(k) приведён на Рис. 5. Вначале вызывается системная функция CreateFile(), кото-рая открывает со стороны клиента именованный канал, созданный ранее со стороны сервера вызовом функций CreateNamedPipe() и ConnectNamedPipe(). Идентификация канала осуществляется по имени \\.\pipe\PeerNetNP_k, где k – номер узла. Если функция CreateFile() выполнилась без ошибки, – канал со-здан, и необходимо обеспечить его использование для обмена. Для этого при помощи функции CreateEvent() создаются три события: «закрытие канала», «запрос клиента готов», «ответ сервера получен», которые используются для 
 
 
Рис. 4. Синхронизация потоков взаимодействующих узлов при запуске
 
Рис. 4 (продолжение). Синхронизация потоков взаимодействующих узлов при запуске   

синхронизации программных потоков. Все три события при создании перево-дятся в состояние «выключено». Затем создаётся программный поток, опре-деляемый процедурой NPClientThreadProc(), после чего завершается проце-дура StartNPClient(k), а программный поток начинает своё выполнение.
В программном потоке клиента выполняется основной цикл обмена со-общениями между 
