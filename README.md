# PeerNetNodex

##Введение
Технология block-chain стремительно развивается не только в сфере криптовалют, но и во многих других областях, где стремятся сократить рас-ходы, повысить эффективность и отказаться от устаревших информационных инфраструктур. В проекте рассматривается наиболее популярный пример ис-пользования block-chain, а именно, в области проведения электронных денеж-ных переводов.
Цель работы
Целью данной работы является разработка алгоритмов и программы, предназначенной для моделирования технологии block-chain на примере про-стой системы «электронного кошелька».
Задачи
В работе были выделены подзадачи:
1. Выполнить анализ требований;
2. Разработать архитектуру приложения;
3. Реализовать приложение для моделирования block-chain;
4. Подготовить документацию.


Ход работы
Теоретическая часть
Принципы организации block-chain
Идея block-chain DLT (Distributed Ledger Technology = технология рас-пределённых регистров, или реестров) представляет собой широкую концеп-цию и набор технологий, в которых имеется база данных или общая запись транзакций, с множеством копий, распределённых среди участников сети. Це-почка блоков или блокчейн хранит информацию в блоках транзакций. В настоящее время появляются новые технологии DLT, которые используют различные структуры хранения данных, такие как Hyperledger или HashGraph.
С точки зрения кибербезопасности протокол blockchain / DLT имеет определённые особенности, которые представляют преимущество перед дру-гими технологиями. 
Сущность распределённой, или децентрализованной, архитектуры со-стоит в том, что участники сети, также известные как узлы, хранят собствен-ную копию записи всех сохранённых в системе данных, которая синхронизи-руется с копиями информации остальных участников. Такое дублирование реестра даёт возможность узлу синхронизировать свою копию реестра, в слу-чае её неактуальности, порчи или утраты, через другие узлы.
В целом, этот тип архитектуры хранения информации менее привлека-телен для злоумышленников, чем централизованные базы данных, которые становятся очень уязвимыми информационными нишами.

Практическая часть
Одноранговая сеть узлов – основа данной модели block-chain
Технология block-chain предполагает наличие сетевой среды, в которой осуществляется обмен блоками данных между узлами сети. При построении модели системы block-chain необходимо иметь доступ хотя бы к небольшому фрагменту сети. Использование реальной сети, локальной или интернет, воз-можно, но затруднительно технически и организационно. Поэтому в качестве сетевой среды в проекте используется модель одноранговой сети.
Желательно, чтобы одноранговая сеть строилась путём многократного запуска одного и того же приложения; при этом каждый экземпляр приложе-ния имитировал бы отдельный сетевой узел. Коммуникация между узлами осуществляется при помощи стандартного механизма операционной системы Windows – именованных каналов (named pipes). В ОС Windows механизм именованных каналов относится к базовым средствам и реализован на уровне ядра. На нём основана реализация ряда протоколов взаимодействия в ОС.
Основными аргументами в пользу такого выбора является относитель-ная простота реализации и ограниченность требуемых средств, а также нали-чие хорошо документированного программного интерфейса.
Соединение двух узлов обычным именованным каналом предполагает разделение функций узлов на сервер и клиент, то есть узлы предполагаются неравноправными. Сервер создаёт именованный канал посредством CreateNamedPipe() и после вызова ConnectNamedPipe() ждёт подключение к каналу со стороны клиента. Клиент вызывает CreateFile() для подключения к каналу со своей стороны. Кстати, именованный канал (что видно и по назва-ниям функций) в операционной системе рассматривается как разновидность потока ввода-вывода. Далее с помощью вызова функций ReadFile() и WriteFile() между сервером и клиентом происходит обмен сообщениями (блоками данных), причём клиент посылает серверу запросы и получает от сервера ответы. В обмене ведущую роль играет клиент, а сервер только от-вечает на запросы клиента. Прекращение обмена может происходить как со стороны клиента вызовом CloseHandle(), так и со стороны сервера вызовом DisconnectNamedPipe(). Описанный протокол взаимодействия, соответствую-щий режиму синхронных операций ввода/вывода, проиллюстрирован на Рис. 1.

 
Рис. 1. Протокол взаимодействия сервера и клиента через 
именованный канал в синхронном режиме.
Разделение функций узлов на сервер и клиенты не подходит для сети, которая была бы основой модели block-chain. Для этой цели нужна одноран-говая сеть, в которой каждый узел мог бы выполнять и функцию сервера, и функцию клиента. Таким образом, в каждом узле должны быть совмещены обе функции.
В предлагаемой модели одноранговой сети каждый узел должен быть соединён с каждым из остальных узлов парой именованных каналов по прин-ципу «точка-точка». Для избежания путаницы каждый сервер создаёт и об-служивает несколько экземпляров канала (по числу клиентов) со своим име-нем. Такой подход приводит к конфигурации сети, приведённой на Рис. 2, для случая трёх узлов. Эту конфигурацию нетрудно обобщить на случай произвольного количества узлов N. Общее количество экземпляров имено-ванных каналов равно N·(N - 1), оно имеет порядок роста N2, что можно счи-тать недостатком предложенного метода построения сети. Но для ограничен-ной модели количество узлов невелико, поэтому данный недостаток можно считать несущественным.

 
Рис. 2. Конфигурация модели одноранговой сети на основе 
именованных каналов (для случая трёх узлов).
Алгоритмы функционирования узла одноранговой сети
Модель рассчитана на формирование одноранговой сети с количеством узлов до семи. Узлы сети образуются экземплярами приложения, которые мо-гут запускаться как на одном и том же, так и на разных компьтерах, включён-ных в одну локальную сеть. В данной версии программной реализации пред-полагается работа на одном компьютере, с целью упрощения поиска подхо-дящих серверов именованных каналов.
Программная реализацияузла одноранговой сети представлена двумя основными классами: CNamedPipe и CPeerNetNode. Реализация как сервера, так и клиента представляет собой многопоточную программу. Отдельный программный поток управляет своим экземпляром именованного канала со стороны сервера, также отдельный программный поток обеспечивает обмен сообщениями по именованному каналу со стороны клиента. Количество про-граммных потоков одного узла определяется по формуле 2(N - 1) + 2 = 2N, где N – общее количество узлов, N-1 – количество узлов, с которыми соеди-нён один узел, +2 – количество потоков, не связанных с именованными кана-лами (основной программный поток и серверный поток «прослушивания» се-ти). Таким образом, общее количество программных потоков, обеспечиваю-щих всю сеть, – 2N2.
В классе CNamedPipe реализованы структуры данных, необходимые для работы с именованными каналами: буферы запроса клиента и ответа сервера, объекты синхронизации выполнения программных потоков, объекты иденти-фикации узла, канала, состояния канала, коды ошибок. Методы класса реали-зуют базовые операции обмена сообщениями по именованному каналу и об-работку ошибок.
В классе CPeerNetNode представлены структуры данных узла одноран-говой сети: массив экземпляров именованного канала серверной части узла, массив именованных каналов клиентской части узла, количество активных уз-лов сети, номер «своего» узла. Методы класса обеспечивают: запуск и останов узла, передачу запроса серверу заданного узла и получение ответа.
Для начала функционирования очередного узла одноранговой сети пользователь должен пройти авторизацию, при которой определяется услов-ный номер пользователя, и вызвать процедуру CPeerNetNode::StartupNode(). Алгоритм запуска узла сети приведён на Рис. 3. Сначала запускается клиент-ская часть узла. В цикле делается попытка запуска клиента поочерёдно на всех каналах. Если попытка на канале k оказывается успешной, значит, узел сети с номером k активен и для него выполняется процедура CPeerNetNode:: 
 
Рис. 3. Алгоритм запуска узла одноранговой сети на основе именованных ка-налов.
StartNPClient(k), которая формирует экземпляр именованного канала со сто-роны клиента и помещает его в k-й элемент массива клиентских каналов. Если на канале k не удаётся запустить клиент, значит, нет узла с номером k, и этот номер вносится в список свободных номеров узлов. По окончании цикла опроса существующих узлов сети будут запущены клиенты всех активных уз-лов, номера неактивных узлов будут помещены в список свободных номеров.
Далее процедурой CPeerNetNode::StartNPServer() запускается серверная часть для первого свободного номера узла; запускаемый узел получает номер. Устанавливается соответствие условного номера пользователя и номера узла, что необходимо для правильной адресации сообщений.
После этого всем активным в данный момент узлам сети, для которых в первой части алгоритма были сформированы клиентские каналы, рассылается служебная команда SCL (StartCLient) – «запустить клиент» для нового узла сети. При получении этой команды в каждом из ранее активных узлов будет запущен клиент и создан канал для связи с вновь запущенным сервером.
Синхронизация программных потоков для случая минимальной конфи-гурации сети из двух узлов иллюстрируется Рис. 4. В этом случае на каждом узле работают по четыре потока: основной программный поток, серверный поток «прослушивания» и пара потоков обслуживания именованных каналов, связывающих узлы.
Алгоритм запуска клиента на k-м канале CPeerNetNode::StartNPClient(k) приведён на Рис. 5. Вначале вызывается системная функция CreateFile(), кото-рая открывает со стороны клиента именованный канал, созданный ранее со стороны сервера вызовом функций CreateNamedPipe() и ConnectNamedPipe(). Идентификация канала осуществляется по имени \\.\pipe\PeerNetNP_k, где k – номер узла. Если функция CreateFile() выполнилась без ошибки, – канал со-здан, и необходимо обеспечить его использование для обмена. Для этого при помощи функции CreateEvent() создаются три события: «закрытие канала», «запрос клиента готов», «ответ сервера получен», которые используются для 
 
 
Рис. 4. Синхронизация потоков взаимодействующих узлов при запуске
 
Рис. 4 (продолжение). Синхронизация потоков взаимодействующих узлов при запуске   

синхронизации программных потоков. Все три события при создании перево-дятся в состояние «выключено». Затем создаётся программный поток, опре-деляемый процедурой NPClientThreadProc(), после чего завершается проце-дура StartNPClient(k), а программный поток начинает своё выполнение.
В программном потоке клиента выполняется основной цикл обмена со-общениями между клиентом и сервером по соответствующему каналу. Сразу после запуска поток при помощи вызова функции WaitForMultipleObjects() переводится в состояние ожидания комбинации событий «закрытие канала» или «запрос клиента готов». Дальнейшее выполнение потока клиента при по-мощи механизма событий координируется с процедурой обмена CPeer-NetNode::RequestAndReply(k, sMes), одной из основных процедур программ-ного интерфейса класса CPeerNetNode (см. Рис. 6). Входными параметрами процедуры RequestAndReply являются номер узла, которому нужно напра-вить запрос, и буфер сообщения с текстом запроса –ссылка на объект струк-турного типа TMessageBuf. Результат выполнения процедуры – указатель бу-фера сообщения в динамической памяти с текстом ответа.
По номеру узла из массива клиентов выбирается объект CNamedPipeклиентской стороны именованного канала, связанного с заданным узлом. Из входного буфера запрос копируется в буфер запроса канала и при помощи вызова SetEvent() возбуждается событие «запрос клиента готов», по-сле чего основной поток приложения (в котором выполняется процедура Re-questAndReply) переводится в состояние ожидания события «ответ сервера получен». Возбуждение события «запрос клиента готов» выводит соответ-ствующий программный поток клиента из состояния ожидания; после провер-ки, наступило ли именно событие «запрос клиента готов», это событие сбра-сывается (ResetEvent) и при помощи WriteFile() запрос передаётся серверу. За-тем вызовом ReadFile() после ожидания будет прочитан ответ сервера и при помощи SetEvent() возбуждено событие «ответ сервера получен», после чего выполнение процедуры RequestAndReply будет продолжено, а поток клиента перейдёт 
 
Рис. 6. Запуск клиента именованного канала.

 
Рис. 7. Взаимодействие процедуры обмена сообщениями 
с потоком клиента именованного канала
в состояние ожидания поступления следующего запроса. После возобновле-ния выполнения процедуры RequestAndReply событие «ответ сервера полу-чен» сбрасывается, ответ сервера копируется из буфера именованного канала во вновь создаваемый динамический буфер сообщения, который и передаётся на выход процедуры RequestAndReply.
Закрытие программного потока клиента осуществляется двумя спосо-бами: 1) возбуждением события «закрытие канала», когда останавливается «свой» узел, 2) служебной командой TRM (Terminate), когда останавливается удалённый узел.
Алгоритм запуска сервера на k-м канале CPeerNetNode::StartNPServer(k) приведён на Рис. 7. В основном программном потоке приложения выполняет-ся только создание программного потока генератора экземпляров именован-ного канала NPServerThreadProc, остальная часть работы сервера реализуется одним потоком упомянутого «генератора» и набором генерируемых про-граммных потоков экземпляров именованного канала. Все экземпляры имеют одно имя канала, определяемое номером «своего» узла.
Как только запускается поток NPServerThreadProc, создаётся новый эк-земпляр объекта CNamedPipe и при помощи вызова CreateNamedPipe() – но-вый экземпляр именованного канала. Затем создаётся событие «закрытие ка-нала» (CreateEvent) и вызывается функция ConnectNamedPipe(), которая пере-водит поток в состояние «прослушивания», то есть ожидания подключения к каналу со стороны какого-либо клиента. В этом состоянии процесс может оставаться неопределённо долго. Из состояния «прослушивания» поток вы-водится при подключении к каналу удалённого или «своего» клиентского процесса с помощью вызова CreateFile(). Сразу после этого проверяется, не активизировано ли событие «закрытие канала». Событие возбуждается для за-крытия серверного потока при останове «своего» узла, иначе создаётся новый поток экземпляра именованного канала NPInstanceThreadProc().
В потоке NPInstanceThreadProc() выполняется цикл обмена сообщения-ми с клиентским процессом удалённого узла. Сразу после запуска потока он переходит в режим чтения с ожиданием запроса клиента вызовом процедуры ReadFile(). Как только запрос будет получен, он передаётся процедуре CPeer-NetNode::GetAnswerToRequest(), в которой запрос обрабатывается и в резуль-тате формируется ответ сервера. Далее ответ сервера клиенту в виде сообще-ния помещается в буфер ответа данного экземпляра именованного канала и с помощью вызова WriteFile() отправляется клиенту. Запросы клиента и ответы сервера, кроме элемента <Блок данных>, являются текстовыми сообщениями, представлеными в кодировке Unicode и имеющими следующий синтаксис:

<Сообщение>::=<Код сообщения>'˽'<Узел-отправитель> <Узел-получатель>[<Блок данных>]
<Код сообщения>::={'ACK'|'DTB'|'SCL'|'TRM'|'TAQ'|'TAR'| 'ATR'|'GDT'|'TBL'}
<Узел-отправитель>::=<Цифра><Цифра>
<Узел-получатель>::=<Цифра><Цифра>
<Блок данных>::=<Размер блока><Байт>..<Байт>
<Размер блока>::=<Цифра><Цифра><Цифра><Цифра>
<Цифра>::='0'-'9'
Пояснение
Код сообщения 	Значение	Примечание
ACK	ACKnowledgement – подтвержде-ние	Команда сетевого уровня
SCL	StartCLient – запустить клиент	Команда сетевого уровня
TRM	TeRMinate – закрыть канал	Команда сетевого уровня
DTB	DaTa Block – блок данных	Команда сетевого уровня
TAQ	TransAction reQuest	Команда прикладного уровня
TAR	TransAction Reply	Команда прикладного уровня
ATR	Actualize Transaction Register	Команда прикладного уровня
GTB	Get Transaction Block	Команда прикладного уровня
TBL	Transaction BLock	Команда прикладного уровня
Сообщения (команды) сетевого уровня (приведены в верхней части таб-лицы) выполняют служебную функцию обеспечения взаимодействия потоков внутри узла и между узлами сети, они полностью обрабатываются внутри ме-тода GetAnswerToRequest() и на прикладной уровень не передаются. Един-ственная из них, команда DTB, имеет блок данных произвольной длины в пределах размера буферов и обеспечивает обмен данными прикладного уров-ня между узлами сети. Эта команда служит оболочкой команд прикладного уровня (приведены в нижней части таблицы), которые помещаются в блок данных. Метод GetAnswerToRequest() обеспечивает распаковку/упаковку (Un-wrap() / Wrap()) команд прикладного уровня из блока данных и передачу их для обработки прикладному уровню.
Узел-отправитель – это двухзначный номер узла, источника сообщения.
Узел-получатель – это двухзначный номер узла, приёмника сообщения.
Размер блока – четырёхзначное число, длина следующего далее блока данных в байтах. Если блок данных содержит строку текста, то это длина с учётом завершающих нулевых байтов.
Выход из цикла обмена сообщениями с клиентским процессом удалён-ного узла и завершение потока NPInstanceThreadProc() происходит после по-лучения от клиента команды TRM. Перед завершением потока выполняется разъединение экземпляра именованного канала DisconnectNamedPipe() и за-крытие дескриптора объекта CloseHandle().

 
Рис. 8. Запуск сервера именованного канала.
 
Рис. 9. Взаимодействие потоков сервера и именованного канала.
Некоторые особенности установления связи по именованному каналу 
между клиентом и сервером
Процессом сервера именованного канала может использоваться функ-ция ConnectNamedPipe() как с вновь созданным экземпляром именованного канала, так и с экземпляром именованного канала, который был ранее под-ключён к клиентскому процессу[1]. В данном случае процесс сервера должен предварительно вызвать функцию DisconnectNamedPipe() для отсоединения дескриптора (хендла) именованного канала от предыдущего клиента, прежде чем он буден соединён с новым клиентом. В противном случае Connect-NamedPipe() возвращает нулевое значение, а функция GetLastError() возвра-щает код ошибки ERROR_NO_DATA, если предыдущий клиент закрыл де-скриптор именованного канала, или код ошибки ERROR_PIPE_CONNECTED, если он этого не сделал.
Поведение функции ConnectNamedPipe() зависит от двух условий: 1) установлен ли именованный канал врежим ожидания с блокированием или без блокирования и 2) вызывается ли функция в синхронном или асинхронном режиме выполнения. Первоначально сервер устанавливает режим ожидания в именованном канале функцией CreateNamed-Pipe(), но в дальнейшем режим может быть изменён функцией SetNamedPipeHandleState().
Процесс сервера может использовать любую функцию ожидания объек-та или функцию SleepEx(), чтобы определить, когда объект-событие перейдёт в возбуждённое состояние, и тогда с помощью макроса HasOverlappedIoCom-pleted определить, завершена ли операция подключения к именованному ка-налу.
Если канал установлен в режим без блокирования, функция Connect-NamedPipe() всегда возвращает управление немедленно. В режиме с блокиро-ванием функция ConnectNamedPipe() возвращает ненулевое значение, если она вызвана первый раз для экземпляра канала, который был отсоединён от предыдущего клиента. Это свидетельствует о том, что канал доступен для подключения к новому клиентскому процессу. Во всех остальных случаях, когда канал находится в режиме без блокирования, ConnectNamedPipe() воз-вращает нулевое значение. При этом GetLastError() возвращает код ошибки ERROR_PIPE_LISTENING, если ни один клиент не подключён, код ошибки ERROR_PIPE_CONNECTED, если подключён какой-либо клиент, и код ошибки ERROR_NO_DATA, если предыдущий клиент со своей стороны за-крыл дескриптор канала, но сервер не выполнил разъединение. Важно отме-тить, что соединение между клиентом и сервером можно считать надёжно установленным только после получения кода «ошибки» ER-ROR_PIPE_CONNECTED.

Реализация модели block-chain в виде простой системы 
«электронного кошелька»
В нашей модели «электронного кошелька» предполагается выполнение единственной операции «оплата»: перевод некоторой суммы из своего ко-шелька в кошелёк другого пользователя. Совокупность действий, которые необходимо предпринять для выполнения этой операции, называется тран-закцией. В системах block-chain каждая транзакция проводится при участии и одобрении многих (в идеале всех) членов сетевого сообщества. Транзакция проходит следующие этапы выполнения:
1)	Формирование «заявки» на проведение транзакции, запроса T(u1, u2, S), где u1 - пользователь, кто переводит, u2 - пользователь, кому переводят, S - сумма перевода.
2)	Запрос транзакции передаётся всем узлам сети на рассмотрение и одоб-рение.
3)	Каждый узел сети (пользователь) на основании сведений, которые име-ются в его собственной копии данных о состоянии счетов и истории транзакций, принимает решение об одобрении или отклонении транзак-ции, о чём направляет сообщение пользователю инициатору запроса – голосование.
4)	Пользователь u1 собирает и анализирует ответы всех участников процес-са и определяет, транзакция одобрена или отклонена.
5)	В случае одобрения все узлы оповещаются об этом, и каждый узел со своей копией данных проводит транзакцию.
Таким образом, при участии всех узлов сети в проведении транзакций у каждого пользователя будет в наличии актуальная локальная копия данных о транзакциях. В нашей модели block-chain каждая транзакция представляется блоком, для которого вычисляется хеш-код. Вся последовательность (исто-рия) транзакций образует цепь хеш-чейн, в которую каждый отдельный поль-зователь не может внести изменение так, чтобы это не было обнаружено сете-вым сообществом. При этом в транзакциях пользователи u1, u2 представлены цифровыми подписями (хеш-кодами), что обеспечивает «анонимность».
Однако, на деле в проведении каждой отдельной транзакции участвуют не все пользователи, а лишь некоторое их подмножество. В результате ло-кальные копии данных тех пользователей, которые не участвовали во всех транзакциях, оказываются неактуальными, то есть возникает нарушение це-лостности данных в совокупности локальных копий, рассматриваемой как распределённая информационная система. Для устранения этой несогласован-ности необходим процесс актуализации данных. В нашей модели актуализа-ция выполняется при проведении первой же транзакции, в которой обнаружи-вается неактуальность локальных данных какого-либо пользователя.

Модель распределённой базы данных
Как уже отмечалось выше, одной из ключевых идей block-chain являют-ся принципы децентрализованного управления и использования распределён-ной системы хранения данных в сети. При построении модели block-chain, приближённой к реальности, не может использоваться никакой другой прин-цип хранения данных, кроме распределённого. В то же время, разработка ре-альной распределённой базы данных представляет собой сложную техниче-скую задачу, выходящую далеко за рамки курсового проекта. Поэтому в дан-ном проекте не ставилась задача воспроизвести распределённую БД, а лишь реализовать в упрощённом виде функцию хранения данных в виде набора файлов специальной структуры. 
В каждом узле одноранговой сети предполагается хранить свою соб-ственную полную копию всех данных, требуемых для работы системы. В нашей модели каждый пользователь работает в отдельном узле сети, который образуется в результате запуска очередного экземпляра одного и того же приложения в многопрограммной операционной системе. Имя сетевого узла определяется очерёдностью запуска экземпляров приложения по схеме: Node #1, Node #2 и т.д. После выполнения пользователем процедуры авторизации (ввод регистрационного имени Login Name, и пароля) система идентифициру-ет пользователя условным именем user_01, user_02 и т.д. и связывает имя се-тевого узла с пользователем. В дальнейшем можно использовать двухуровне-вую адресацию сообщений, которыми обмениваются участники процесса: нижний уровень физический – по номерам узлов сети, верхний уровень логи-ческий – по условному номеру пользователей.
В предметной области транзакций выделены три сущности:
1)	Список (таблица) пользователей с элементами данных (полями):
- условное имя пользователя,
- регистрационное имя (login),
- пароль,
- хеш-код регистрационного имени – открытый ключ шифрования.
2)	Список (таблица) текущих остатков с элементами данных (полями):
- условное имя пользователя,
- хеш-код регистрационного имени,
- текущий остаток счёта.
3)	Список (таблица) блоков хеш-чейн транзакций с элементами данных (по-лями):
- хеш-код предыдущего блока,
- номер транзакции,
- хеш-код регистрационного имени «кто»,
- хеш-код регистрационного имени «кому»,
- сумма транзакции.
В программной реализации три перечисленные сущности представлены тремя классами CUserRegister, CBalanceRegister, CTransactRegister, производ-ными от базового класса CFileBase, в котором реализованы общие элементы данных и основные методы интерфейса: Load(), Save(), Add(), Find() (см. Приложение 1). Каждый из трёх объектов представляется в памяти типизиро-ванным динамическим массивом – шаблонным классом CTypedPtrAr-ray<TYPE *>. Внешнее представление – файлы, размещённые в рабочем ката-логе: UserList.dat – регистр пользователей, один файл с разделяемым досту-пом на чтение; Balnc_nn.dat – регистры текущих остатков, для каждого поль-зователя свой файл; Trans_nn.dat – регистры (журналы) транзакций, для каж-дого пользователя свой файл.

 
Рис. 10. Общий алгоритм проведения транзакции.
 
Рис. 11. Алгоритм анализа результатов голосования по запросу транзакции.

 
Рис. 12. Алгоритм исполнения транзакции.

 
Рис. 13. Алгоритм актуализации журнала транзакций.

Основные классы приложения и их взаимосвязь
Описанные выше алгоритмы реализованы программно в виде набора следующих основных классов:
CPNNDialog – класс основного окна приложения, производного от CDialog, класса диалогового окна в библиотеке MFC. В этом классе реализу-ются все функции пользовательского интерфейса приложения: управление, ввод и отображение информации в процессе проведения транзакций.
CPeerNetNode – класс, реализующий узел одноранговой сети, внутри которого используется класс CNamedPipe, инкапсулирующий функции име-нованного канала.
CBlockChain – класс, реализующий алгоритмы проведения транзакций в модели распределённой системы электронных кошельков с использованием технологиии block-chain, включая ведение личных копий истории транзакций, актуализацию этих копий, счетов всех участников системы. В качестве эле-ментов класса используются объекты классов CCrypto, CUserRegister, CBal-anceRegister, CTransRegister. Взаимосвязь классов показана представлена на следующем Рис. 13.
 
Рис. 14. Взаимосвязь основных классов приложения.
Результаты
Проведён обзор теоретических материалов по проблематике block-chain технологий. 
Реализована программа, моделирующая фрагмент одноранговой сети.
Разработана простая реализация распределённой базы данных для хра-нения транзакций.
Разработаны алгоритмы и реализована программа простого «электрон-ного кошелька» для проведения взаиморасчётов по технологии block-chain с использованием шифрования идентифицирующих данных пользователей по методу открытого-закрытого ключа. 

Список использованной литературы
1.	Документация Mocrosoft. https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe

